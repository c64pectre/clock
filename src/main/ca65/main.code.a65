;    clock: Clock application for the Commodore 64.
;    Copyright (C) 2022  C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/clock/ create an issue

DEBUG_CLOCK_1_Y = 23
DEBUG_CLOCK_1_X = 11
DEBUG_CLOCK_1_DISPLAY = SCREEN_TEXT_RAM + VIC_CHAR_COLUMNS * DEBUG_CLOCK_1_Y + DEBUG_CLOCK_1_X

DEBUG_CLOCK_2_Y = 23
DEBUG_CLOCK_2_X = 28
DEBUG_CLOCK_2_DISPLAY = SCREEN_TEXT_RAM + VIC_CHAR_COLUMNS * DEBUG_CLOCK_2_Y + DEBUG_CLOCK_2_X

IRQ_AT_RASTER_LINE = VIC_VISIBLE_SCREEN_OFFSET_Y + VIC_VISIBLE_SCREEN_SIZE_Y + 1

;;; summary: TOD from/to CIA, to display; 24-hour clock
TOD       = ZP_2_FIRST + 0
TOD_10THS = TOD + 0
TOD_SEC   = TOD + 1
TOD_MIN   = TOD + 2
TOD_HR    = TOD + 3  ; 24-hour

;;; summary: Alarm TOD; 24-hour clock
;;; notes: we keep a copy here because we can only write the alarm to the CIA
ALARM       = ZP_2_FIRST + 4
ALARM_10THS = ALARM + 0
ALARM_SEC   = ALARM + 1
ALARM_MIN   = ALARM + 2
ALARM_HR    = ALARM + 3  ; 24-hour

EVENT_LOOP_SIGNAL = ZP_4_FIRST + 0                          ; byte
EVENT_LOOP_SIGNAL_DOWN = $00                                ; bit, bpl
EVENT_LOOP_SIGNAL_UP   = $80                                ; bit, bmi

DISPLAY_0_Y = 1
DISPLAY_0_X = 1
DISPLAY_0_START = SCREEN_COLOR_RAM + DISPLAY_0_Y * VIC_CHAR_COLUMNS + DISPLAY_0_X

DISPLAY_1_Y = 13
DISPLAY_1_X = 1
DISPLAY_1_START = SCREEN_COLOR_RAM + DISPLAY_1_Y * VIC_CHAR_COLUMNS + DISPLAY_1_X

DISPLAY_10THS_FALSE = $00
DISPLAY_10THS_TRUE  = $FF

;;; summary: main
.proc main
    jsr initialize
    jsr event_loop
    jsr finalize
    ;
    rts
.endproc

;;; summary: Initialize
.proc initialize
    jsr display_main_screen
    jsr initialize_cia_1_tod_frequency
    jsr initialize_cia_2_tod_frequency
    jsr initialize_clock_1
    jsr initialize_clock_2
    jsr set_irq_handler
    ;
    rts
.endproc

.proc finalize
    jsr unset_irq_handler
    rts
.endproc

;;; summary: Display main screen
.proc display_main_screen
    lda # CONFIG_BORDER_COLOR
    sta VIC_EC
    lda # CONFIG_BACKGROUND_COLOR
    sta VIC_B0C
    ;
    ldaxv INIT_MAIN_SCREEN
    jsr puts

    from
        ldx # 250
    loop
        lda MAIN_SCREEN           - 1, x
        sta SCREEN_TEXT_RAM       - 1, x
        lda MAIN_SCREEN     + 250 - 1, x
        sta SCREEN_TEXT_RAM + 250 - 1, x
        lda MAIN_SCREEN     + 500 - 1, x
        sta SCREEN_TEXT_RAM + 500 - 1, x
        lda MAIN_SCREEN     + 750 - 1, x
        sta SCREEN_TEXT_RAM + 750 - 1, x
    next
        dex
        bne _loop
    end
    ;
    rts
.endproc

;;; summary: Put string
;;; input:
;;;   AX = pointer to null terminated string
.proc puts
    from
        ldy # 0
    loop
        lda [AX] , y
        beq _end                                            ; break
        jsr KERNAL_CHROUT
    next
        iny
        bne _loop
        inc AH
        bne _loop
    end
    ;
    rts
.endproc

.proc work
    jsr read_cia_1_to_tod
   ;jsr display_debug_clock_1
    jsr display_clock
    ;
    jsr read_cia_2_to_tod
   ;jsr display_debug_clock_2
    jsr display_stopwatch
    ;
    rts
.endproc

;;; summary: Display clock (TOD on top display)
.proc display_clock
    ldx # 0                                                 ; display 0
    lda # DISPLAY_10THS_FALSE
    jsr display
    rts
.endproc

;;; summary: Display stopwatch (TOD on bottom display)
.proc display_stopwatch
    ldx # 1                                              ; display 1
    lda DISPLAY_10THS_TRUE
    jsr display
    rts
.endproc

;;; summary: Display TOD on display i
;;; input:
;;;   A = Display 10ths? (==0: false, !=0: true)
;;;   X = Display ID (0 or 1)
;;; changed: A, X, Y, AX, BX, CX, DX
.proc display
    ; AL = display 10ths?
    ; AH = led color
    ; BX = pointer in color RAM to top left corner of the display
    ; CL = count digits
    ;
    sta AL
    ;
    lda MAP_DISPLAY_ID_TO_LED_COLOR , x
    sta AH
    ;
    lda MAP_DISPLAY_ID_TO_START_LO , x
    sta BL
    lda MAP_DISPLAY_ID_TO_START_HI , x
    sta BH
    ;
    from
        ldclv 6
            ; 6  5  4  3  2  1  0
            ; H_ _H M_ _M S_ _S T
    loop
        ; assert 0 <= CL && CL <= 6
        lda CL
        lsr
        if_cc_then
            tax
            lda TOD , x
            sta CH
            ldx CL
            if_ne_then
                lsr
                lsr
                lsr
                lsr
            else_end
            jmp _end
        else
            lda CH
            and # $0f
        end
        ;
        ldx CL
        if
            bne _then
            ldx AL
            beq _end
        then
            jsr display_digit
        else_end
        ;
        clc
        ldx CL
        lda DISPLAY_DIGIT_INCREMENTEL_OFFSET_REVERSED , x
        adc BL
        sta BL
        if_cs_then
            inc BH
        else_end
    next
        dec CL
        bpl _loop
    end
    ;
    rts
.endproc

;;; summary: Display Seven-Segment Display (SSD) digit
;;; input:
;;;   A  = Digit to display
;;;   AH = Segment lit color
;;;   BX = pointer in color RAM to top left corner of the SSD
;;; require:
;;;   0 <= A && A <= 9
;;; changed: A, X, Y, DL
.proc display_digit
    ; DL = Segments
    ;
    tax
    lda MAP_DIGIT_TO_SEGMENTS , x
    sta DL
    from
        ldx # 6
    loop
        lsr DL
        if_cs_then
            lda AH
            jmp _end
        else
            lda # CONFIG_DISPLAY_LED_DIM_COLOR
        end
        ;
        ldy OFFSET_SSD_SEGMENT_1 , x
        sta [BX] , y
        ldy OFFSET_SSD_SEGMENT_2 , x
        sta [BX] , y
    next
        dex
        bpl _loop
    end
    ;
    rts
.endproc

;;; summary: debug display TOD_0
.proc display_debug_clock_1
    from
        ldy # 0
        ldx # (CIA_TOD_HR - CIA_TOD_10THS)
    loop
        lda TOD , x
        pha
            lsr
            lsr
            lsr
            lsr
            ora # %00110000                         ; $0..$f to charset '0' .. '9'
            sta DEBUG_CLOCK_1_DISPLAY , y
            iny
        pla
        and # $0f
        ora # %00110000
        sta DEBUG_CLOCK_1_DISPLAY , y
        iny
        iny
    next
        dex
        bpl _loop
    end
    ;
    rts
.endproc

.proc display_debug_clock_2
    from
        ldy # 0
        ldx # (CIA_TOD_HR - CIA_TOD_10THS)
    loop
        lda TOD , x
        pha
            lsr
            lsr
            lsr
            lsr
            ora # %00110000
            sta DEBUG_CLOCK_2_DISPLAY , y
            iny
        pla
        and # $0f
        ora # %00110000
        sta DEBUG_CLOCK_2_DISPLAY , y
        iny
        iny
    next
        dex
        bpl _loop
    end
    ;
    rts
.endproc

;;; summary: Initialize CIA-1 TOD frequency depending on PAL/NTSC (not reliable on exotic models)
.proc initialize_cia_1_tod_frequency
    lda # PAGE_CIA_1
    jsr initialize_cia_tod_frequency
    ;
    rts
.endproc

;;; summary: Initialize CIA-2 TOD frequency depending on PAL/NTSC (not reliable on exotic models)
.proc initialize_cia_2_tod_frequency
    lda # PAGE_CIA_2
    jsr initialize_cia_tod_frequency
    ;
    rts
.endproc

;;; summary: Initialize CIA-i TOD frequency depending on PAL/NTSC (not reliable on exotic models)
;;; input:
;;;   A = page of CIA
;;; changed: A, X, Y, AX
.proc initialize_cia_tod_frequency
    sta AH
    clral
    ldy # CIA_CRA
    lda [AX] , y
    and # CIA_CRA_RTC_FREQUENCY_CLR
    ldx KVAR_PALNTS                                         ; $00: NTSC, $01: PAL
    if_ne_then
        ora # CIA_CRA_RTC_FREQUENCY_50HZ
        bne _end                                            ; bra
    else
       ;ora # CIA_CRA_RTC_FREQUENCY_60HZ                    ; optimize: delete instruction because operand is zero
    end
    ;
    sta [AX] , y
    ;
    rts
.endproc

;;; summary: Initializa TOD of CIA-1 to 00:00:00.0 [24-hour clock] = AM 12:00:00.0 [12-hour clock] and start it
.proc initialize_clock_1
    lda # $12
    sta TOD_HR
    lda # $00
    sta TOD_MIN
    sta TOD_SEC
    sta TOD_10THS
    jsr write_tod_to_cia_1
    ;
    rts
.endproc

;;; summary: Initializa TOD of CIA-2 to 00:00:00.0 [24-hour clock] = AM 12:00:00.0 [12-hour clock], and start it
;;; todo: Make it so that is does not start running
.proc initialize_clock_2
    lda # $00
    sta TOD_HR
    sta TOD_MIN
    sta TOD_SEC
    sta TOD_10THS
    jsr write_tod_to_cia_2
    ;
    rts
.endproc

;;; summary: Link IRQ handler
;;; changed: A
.proc set_irq_handler
    sei
        ; Set IRQ at raster
        lda # IRQ_AT_RASTER_LINE
        sta VIC_RST
        lda VIC_CONTROL_1
        and # VIC_CONTROL_1_RST8_CLR
        sta VIC_CONTROL_1
        ; Enable raster IRQ
        lda VIC_IE
        ora # VIC_IE_RST_SET
        sta VIC_IE
        ;
        ldwv KERNAL_CINV, irq_handler
    cli
    ;
    rts
.endproc

;;; summary: Unlink IRQ handler
;;; changed: A
.proc unset_irq_handler
    sei
        ; Disable raster IRQ
        lda VIC_IE
        and # VIC_IE_RST_CLR
        sta VIC_IE
        ;
        ldwv KERNAL_CINV, KERNAL_INTERNAL_KEY
    cli
    ;
    rts
.endproc

;;; summary: IRQ handler
.proc irq_handler
    ; check I == 1
    ;
    bit VIC_IR
    if_mi_then
        ; VIC interrupt
        ; Clear all VIC interrupts
        lda # $FF
        sta VIC_IR
        ;
       ;dec VIC_EC
            jsr work
       ;inc VIC_EC
    else_end
    ;
    jmp KERNAL_INTERNAL_KEY
.endproc

.proc event_loop
    from
        ldbv EVENT_LOOP_SIGNAL, EVENT_LOOP_SIGNAL_DOWN
    loop
        jsr KERNAL_GETIN                                    ; 0 = no key pressed
        jsr find_command
        lda # > (_next - 1)
        pha
        lda # < (_next - 1)
        pha
        lda COMMAND_HANDLER_HI , x
        pha
        lda COMMAND_HANDLER_LO , x
        pha
        php
        rti                                                 ; jsr command handler
    next
        bit EVENT_LOOP_SIGNAL
        bpl _loop
    end
    ;
    rts
.endproc

;;; summary: find command index from character in A, or else 0
;;; input:
;;;   A = Command character
;;; output:
;;;   X = Command index
.proc find_command
    from searching
        ldx # 0
    loop
        cmp COMMAND_KEY_ARRAY , x
        if_then
            beq searching::_end                             ; break
        else_end
    next
        inx
        bne _loop                                           ; bra
    end
    ;
    rts
.endproc

;;; summary: Idle (do nothing)
.proc idle
    rts
.endproc

;;; summary: Signal exit
.proc exit
    ldbv EVENT_LOOP_SIGNAL, EVENT_LOOP_SIGNAL_UP
    rts
.endproc

;;; summary: increment clock hour by 1, wrapping on 23 to 00
.proc hour_inc
    sei
        jsr read_cia_1_to_tod
        ldx # 3
        jsr do_inc
        jsr write_tod_to_cia_1
    cli
    ;
    rts
.endproc

;;; summary: Increment TOD part
;;; input:
;;;    X = part: 0 = 10THS , 1 = SEC , 2 = MIN , 3 = HR
;;; require:
;;;   I == 1
.proc do_inc
    lda TOD , x
    cmp TOD_PART_MAX , x
    if_eq_then
        lda TOD_PART_MIN , x
        beq _end                                            ; bra
    else
        sed
            clc
            adc # 1                                         ; note: inc won't work here because BCD
        cld
    end
    ;
    sta TOD , x
    ;
    rts
.endproc

;;; summary: decrement clock hour by 1
.proc hour_dec
    sei
        jsr read_cia_1_to_tod
        ldx # 3
        jsr do_dec
        jsr write_tod_to_cia_1
    cli
    ;
    rts
.endproc

;;; summary: Decrement TOD part
;;; input:
;;;    X = part: 0 = 10THS , 1 = SEC , 2 = MIN , 3 = HR
;;; require:
;;;   I == 1
.proc do_dec
    lda TOD , x
    cmp TOD_PART_MIN , x
    if_eq_then
        lda TOD_PART_MAX , x
        beq _end                                            ; bra
    else
        sed
            sec
            sbc # 1                                         ; note: dec won't work here because BCD
        cld
    end
    ;
    sta TOD , x
    ;
    rts
.endproc

;;; summary: increment clock minute by 1
.proc minute_inc
    sei
        jsr read_cia_1_to_tod
        ldx # 2
        jsr do_inc
        jsr write_tod_to_cia_1
    cli
    ;
    rts
.endproc

;;; summary: decrement clock minute by 1
.proc minute_dec
    sei
        jsr read_cia_1_to_tod
        ldx # 2
        jsr do_dec
        jsr write_tod_to_cia_1
    cli
    ;
    rts
.endproc

;;; summary: increment clock second by 1
.proc second_inc
    sei
        jsr read_cia_1_to_tod
        ldx # 1
        jsr do_inc
        jsr write_tod_to_cia_1
    cli
    ;
    rts
.endproc

;;; summary: decrement clock second by 1
.proc second_dec
    sei
        jsr read_cia_1_to_tod
        ldx # 1
        jsr do_dec
        jsr write_tod_to_cia_1
    cli
    ;
    rts
.endproc

;;; summary: Read CIA-1 TOD to TOD, converting the hour to 24 hour clock
;;; output:
;;;   TOD = clock with hour on 24-hour clock
;;; uses: A, AX, y
.proc read_cia_1_to_tod
    lda # PAGE_CIA_1
    jsr read_cia_to_tod
    ;
    rts
.endproc

;;; summary: Read CIA-2 TOD to TOD, converting the hour to 24 hour clock
;;; output:
;;;   TOD = clock with hour on 24-hour clock
;;; uses: A, AX, y
.proc read_cia_2_to_tod
    lda # PAGE_CIA_2
    jsr read_cia_to_tod
    ;
    rts
.endproc

;;; summary: Read CIA-i TOD to TOD, converting the hour to 24 hour clock
;;; input:
;;;   A = page of CIA
;;; output:
;;;   TOD = clock with hour on 24-hour clock
;;; uses: A, AX, y
;;; notes:
;;;   Read CIA_i.TOD_HR latches and read CIA.TOD_10THS releases latch.
.proc read_cia_to_tod
    sta AH
    ldalv CIA_TOD_10THS
    from
        ldy # (CIA_TOD_HR - CIA_TOD_10THS)
    loop
        lda [AX] , y
        sta TOD , y
    next
        dey
        bpl _loop
    end
    ;
    lda TOD_HR
    jsr tod_hr_to_h24
    sta TOD_HR
    ;
    rts
.endproc

;;; summary: Write TOD to CIA-1 TOD , converting the hour from 24 hour clock
;;; input:
;;;   TOD = TOD with hourin 24-hour clock format
;;; uses: A, AX, y, x
.proc write_tod_to_cia_1
    lda # PAGE_CIA_1
    jsr write_tod_to_cia
    rts
.endproc

;;; summary: Write TOD to CIA-2 TOD , converting the hour from 24 hour clock
;;; input:
;;;   TOD = TOD with hourin 24-hour clock format
;;; uses: A, AX, y, x
.proc write_tod_to_cia_2
    lda # PAGE_CIA_2
    jsr write_tod_to_cia
    rts
.endproc

;;; summary: Write TOD to CIA-i TOD , converting the hour from 24 hour clock
;;; input:
;;;   A = page of CIA
;;;   TOD = TOD with hourin 24-hour clock format
;;; uses: A, AX, y, x
;;; notes:
;;;   Write CIA_i.TOD_HR stops clock and write CIA.TOD_10THS starts clock.
.proc write_tod_to_cia
    sta AH
    ldalv CIA_TOD_10THS
    ;
    lda TOD_HR
    jsr h24_to_tod_hr
    sta TOD_HR
    ;
    from
        ldy # (CIA_TOD_HR - CIA_TOD_10THS)
    loop
        lda TOD , y
        sta [AX] , y
    next
        dey
        bpl _loop
    end
    ;
    rts
.endproc

;;; summary: convert TOD hour (12-hour clock) to hour on 24-hour clock
;;; input:
;;;   A = TOD_HR
;;; output:
;;;   A = hour on 24 hour clock in BCD
;;; require:
;;;   ($01 <= A and A <= $09) or ($10 <= A and A <= $12) or ($81 <= A and A <= $89) or ($90 <= A and A <= $92)
;;; ensure:
;;;   ($00 <= A and A <= $09) or ($10 <= A and A <= $19) or ($20 <= A and A <= $23)
.proc tod_hr_to_h24
    ; check I == 1
    cmp # $80
    if_ge_then if_ge_80
        ; A >= $80
        cmp # $92
        if_eq_then
            lda # $12
            bne if_ge_80::_end                              ; optimization because no code after end
        else
            sed
                sec
                sbc # $68
            cld
            ; check A != 0
        end
        ;
        bne _end                                            ; bra
    else
        ; A < $81
        cmp # $12
        if_eq_then
            lda # $00
        else_end
    end
    ;
    rts
.endproc

;;; summary: convert hour on 24-hour clock to TOD hour (12-hour clock)
;;; input:
;;;   A = hour on 24 hour clock in BCD
;;; output:
;;;   A = TOD_HR
;;; require:
;;;   ($00 <= A and A <= $09) or ($10 <= A and A <= $19) or ($20 <= A and A <= $23)
;;; ensure:
;;;   ($01 <= A and A <= $09) or ($10 <= A and A <= $12) or ($81 <= A and A <= $89) or ($90 <= A and A <= $92)
.proc h24_to_tod_hr
    ; check I == 1
    cmp # $13
    if_ge_then
        ; A >= $13
        sed
            clc
            adc # $68
        cld
        bne _end                                            ; bra
    else
        ; A < $13
        cmp # $00
        if_eq_then
            lda # $92
        else_end
    end
    ;
    rts
.endproc
